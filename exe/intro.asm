; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	\\ahs\ahsfiles\Users\AHS-CO\Steven.Ulfelder\Personal Projects\Shoshin\Shoshin\src\intro.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0HA@GIFBHAJB@version?5430?6layout?5?$CIlocation?$DN0?$CJ?5@ ; `string'
PUBLIC	??_C@_0GLG@MLCDAMME@?$CDversion?5430?6out?5vec4?5FragColori@ ; `string'
;	COMDAT ??_C@_0GLG@MLCDAMME@?$CDversion?5430?6out?5vec4?5FragColori@
CONST	SEGMENT
??_C@_0GLG@MLCDAMME@?$CDversion?5430?6out?5vec4?5FragColori@ DB '#version'
	DB	' 430', 0aH, 'out vec4 FragColorin vec2 px;uniform vec4 fpar4['
	DB	'4];int XRES = 1280;int YRES = 720;float EPSILON = 0.01;float '
	DB	'sdfSphere(vec3 p, float r){return length(p) - r;}float sdfSce'
	DB	'ne(vec3 p){// infinite 3D domain repitionp.x = mod(p.x+1.0, 2'
	DB	'.0) - 1.0;p.y = mod(p.y+1.0, 2.0) - 1.0;p.z = mod(p.Z+1.0, 2.'
	DB	'0) - 1.0;float d = sdfSphere(p, 0.5);return d;}vec3 estimateS'
	DB	'dfNormal(vec3 p){return normalize(vec3(sdfScene(vec3(p.x + EP'
	DB	'SILON, p.y, p.z)) - sdfScene(vec3(p.x - EPSILON, p.y, p.z)),s'
	DB	'dfScene(vec3(p.x, p.y + EPSILON, p.z)) - sdfScene(vec3(p.x, p'
	DB	'.y - EPSILON, p.z)),sdfScene(vec3(p.x, p.y, p.z + EPSILON)) -'
	DB	' sdfScene(vec3(p.x, p.y, p.z - EPSILON))));}vec3 simpleLamber'
	DB	't(vec3 normal, vec3 col){vec3 lightDir = vec3(1.0, 2.0, 4.0);'
	DB	'vec3 lightCol = vec3(1.0, 1.0, 1.0);float NdotL = max(dot(nor'
	DB	'mal, lightDir), 0);vec3 c = vec3(col * lightCol * NdotL);retu'
	DB	'rn c;}void main(){// uv are fragcoords (pixels) mapped from ['
	DB	'xres, yres] to [0, 1]vec2 uv = px.xy /* / vec2(XRES, YRES))*/'
	DB	' * vec2(1.7777, 1.0);vec3 cameraPos = vec3(0, 1.0, -4.0);vec3'
	DB	' target = vec3(0);vec3 w = normalize(cameraPos - target);vec3'
	DB	' u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));vec3 v = cross('
	DB	'u, w);vec3 rayOrigin = cameraPos;', 09H, '// send rays from c'
	DB	'amera locationvec3 rayDir = normalize(uv.x * u + uv.y * v + 0'
	DB	'.75*w);', 09H, '// send one ray per pixel 1.0 clip units into'
	DB	' the scenefloat rayDepth = 0.0;vec3 col = vec3(0.2, 0.2, 0.2)'
	DB	';for(int i = 0; i < 100; i++)', 09H, '// send 100 rays total '
	DB	'from camera into scene{float d = sdfScene(rayOrigin + rayDept'
	DB	'h * rayDir);if(d < EPSILON){col = simpleLambert(estimateSdfNo'
	DB	'rmal(rayOrigin + rayDepth * rayDir), vec3(0.2, 0.2, 0.8));bre'
	DB	'ak;}rayDepth += d;if(rayDepth >= 100){col = vec3(0.2, 0.2, 0.'
	DB	'2);}}FragColor = vec4(col, 1.0);}', 00H	; `string'
CONST	ENDS
fsh	SEGMENT
?fsh@@3PBDB DD	FLAT:??_C@_0GLG@MLCDAMME@?$CDversion?5430?6out?5vec4?5FragColori@ ; fsh
fsh	ENDS
;	COMDAT ??_C@_0HA@GIFBHAJB@version?5430?6layout?5?$CIlocation?$DN0?$CJ?5@
CONST	SEGMENT
??_C@_0HA@GIFBHAJB@version?5430?6layout?5?$CIlocation?$DN0?$CJ?5@ DB 'ver'
	DB	'sion 430', 0aH, 'layout (location=0) in vec3 aPos;out vec2 px'
	DB	';void main(){gl_Position=vec4(aPos, 1.0);px = aPos.xy;}', 00H ; `string'
CONST	ENDS
vsh	SEGMENT
?vsh@@3PBDB DD	FLAT:??_C@_0HA@GIFBHAJB@version?5430?6layout?5?$CIlocation?$DN0?$CJ?5@ ; vsh
vsh	ENDS
PUBLIC	?intro_init@@YIXXZ				; intro_init
PUBLIC	?intro_do@@YIXJ@Z				; intro_do
PUBLIC	__real@00000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3f800000
PUBLIC	__real@42c80000
EXTRN	__imp__glRects@16:PROC
EXTRN	?EXT_Init@@YIXXZ:PROC				; EXT_Init
EXTRN	?myglfunc@@3PAPAXA:BYTE				; myglfunc
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?fsid@@3HA DD	01H DUP (?)				; fsid
?fparams@@3PAMA DD 010H DUP (?)				; fparams
_BSS	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Ogspy
; File \\ahs\ahsfiles\users\ahs-co\steven.ulfelder\personal projects\shoshin\shoshin\src\intro.cpp
;	COMDAT ?intro_do@@YIXJ@Z
intromain	SEGMENT
_time$ = -4						; size = 4
?intro_do@@YIXJ@Z PROC					; intro_do, COMDAT
; _time$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _time$[ebp], ecx

; 41   :     const float t  = 0.001f*(float)time;

	fild	DWORD PTR _time$[ebp]

; 42   : 
; 43   :     // camera position
; 44   :     //fparams[ 0] = 2.0f*sinf(1.0f*t+0.1f);
; 45   : 	fparams[0] = t * 100;
; 46   :     fparams[ 1] = 0.0f;
; 47   :     fparams[ 2] = 2.0f*cosf(1.0f*t);
; 48   :     // camera target
; 49   :     fparams[ 4] = 0.0f;
; 50   :     fparams[ 5] = 0.0f;
; 51   :     fparams[ 6] = 0.0f;
; 52   :     // sphere
; 53   :     fparams[ 8] = 0.0f;
; 54   :     fparams[ 9] = 0.0f;
; 55   :     fparams[10] = 0.0f;
; 56   :     fparams[11] = 1.0f;
; 57   : 
; 58   :     oglProgramUniform4fv( fsid, 0, 4, fparams );

	push	OFFSET ?fparams@@3PAMA
	push	4
	push	0
	push	DWORD PTR ?fsid@@3HA
	fmul	DWORD PTR __real@3a83126f
	fld	DWORD PTR __real@42c80000
	fmul	ST(0), ST(1)
	fstp	DWORD PTR ?fparams@@3PAMA
	fldz
	fst	DWORD PTR ?fparams@@3PAMA+4
	fxch	ST(1)
	fcos
	fadd	ST(0), ST(0)
	fstp	DWORD PTR ?fparams@@3PAMA+8
	fst	DWORD PTR ?fparams@@3PAMA+16
	fst	DWORD PTR ?fparams@@3PAMA+20
	fst	DWORD PTR ?fparams@@3PAMA+24
	fst	DWORD PTR ?fparams@@3PAMA+32
	fst	DWORD PTR ?fparams@@3PAMA+36
	fstp	DWORD PTR ?fparams@@3PAMA+40
	fld1
	fstp	DWORD PTR ?fparams@@3PAMA+44
	call	DWORD PTR ?myglfunc@@3PAPAXA+16

; 59   : 
; 60   :     glRects( -1, -1, 1, 1 );

	push	1
	push	1
	push	-1
	push	-1
	call	DWORD PTR __imp__glRects@16

; 61   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?intro_do@@YIXJ@Z ENDP					; intro_do
intromain	ENDS
; Function compile flags: /Ogspy
; File \\ahs\ahsfiles\users\ahs-co\steven.ulfelder\personal projects\shoshin\shoshin\src\intro.cpp
;	COMDAT ?intro_init@@YIXXZ
introinit	SEGMENT
_pid$ = -4						; size = 4
?intro_init@@YIXXZ PROC					; intro_init, COMDAT

; 17   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 18   : 	EXT_Init();

	call	?EXT_Init@@YIXXZ			; EXT_Init

; 19   : 
; 20   :     int vsid = oglCreateShaderProgramv( GL_VERTEX_SHADER,   1, &vsh );

	push	OFFSET ?vsh@@3PBDB
	push	1
	push	35633					; 00008b31H
	call	DWORD PTR ?myglfunc@@3PAPAXA

; 21   :         fsid = oglCreateShaderProgramv( GL_FRAGMENT_SHADER, 1, &fsh );

	push	OFFSET ?fsh@@3PBDB
	push	1
	push	35632					; 00008b30H
	mov	esi, eax
	call	DWORD PTR ?myglfunc@@3PAPAXA
	mov	DWORD PTR ?fsid@@3HA, eax

; 22   :  
; 23   :     unsigned int pid;
; 24   :     oglGenProgramPipelines(1, &pid);

	lea	eax, DWORD PTR _pid$[ebp]
	push	eax
	push	1
	call	DWORD PTR ?myglfunc@@3PAPAXA+4

; 25   :     oglBindProgramPipeline(pid);

	push	DWORD PTR _pid$[ebp]
	call	DWORD PTR ?myglfunc@@3PAPAXA+8

; 26   :     oglUseProgramStages(pid, GL_VERTEX_SHADER_BIT, vsid);

	push	esi
	push	1
	push	DWORD PTR _pid$[ebp]
	call	DWORD PTR ?myglfunc@@3PAPAXA+12

; 27   :     oglUseProgramStages(pid, GL_FRAGMENT_SHADER_BIT, fsid);

	push	DWORD PTR ?fsid@@3HA
	push	2
	push	DWORD PTR _pid$[ebp]
	call	DWORD PTR ?myglfunc@@3PAPAXA+12
	pop	esi

; 28   : 
; 29   :     /*#ifdef DEBUG
; 30   :         int		result;
; 31   :         char    info[1536];
; 32   :         oglGetProgramiv( vsid, GL_LINK_STATUS, &result ); oglGetProgramInfoLog( vsid, 1024, NULL, (char *)info ); if( !result ) DebugBreak();
; 33   :         oglGetProgramiv( fsid, GL_LINK_STATUS, &result ); oglGetProgramInfoLog( fsid, 1024, NULL, (char *)info ); if( !result ) DebugBreak();
; 34   :         oglGetProgramiv( pid,  GL_LINK_STATUS, &result ); oglGetProgramInfoLog( pid,  1024, NULL, (char *)info ); if( !result ) DebugBreak();
; 35   :     #endif*/
; 36   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?intro_init@@YIXXZ ENDP					; intro_init
introinit	ENDS
; Function compile flags: /Ogspy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 635  :         return (float)cos(_X);

	fld	DWORD PTR __X$[esp-4]
	fcos

; 636  :     }

	ret	0
_cosf	ENDP
_TEXT	ENDS
END
